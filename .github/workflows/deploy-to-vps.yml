name: Deploy Django Backend to VPS

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Docker image tag to deploy (e.g., latest, v1.0.0, main-abc123)'
        required: true
        default: 'latest'
      vps_host:
        description: 'VPS hostname or IP address'
        required: true
      ssh_user:
        description: 'SSH username'
        required: true
        default: 'root'
      deployment_path:
        description: 'Deployment path on VPS'
        required: true
        default: '/opt/resolvemeq'

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_KEY }}

      - name: Add VPS to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ inputs.vps_host }} >> ~/.ssh/known_hosts


      - name: Ensure deployment directory exists and copy docker-compose
        env:
          SSH_USER: ${{ inputs.ssh_user }}
          VPS_HOST: ${{ inputs.vps_host }}
          DEPLOY_PATH: ${{ inputs.deployment_path }}
        run: |
          ssh ${SSH_USER}@${VPS_HOST} "sudo mkdir -p ${DEPLOY_PATH} && sudo chown -R ${SSH_USER}:${SSH_USER} ${DEPLOY_PATH} && ls -ld ${DEPLOY_PATH}"
          scp docker-compose.production.yml ${SSH_USER}@${VPS_HOST}:${DEPLOY_PATH}/docker-compose.yml
          ssh ${SSH_USER}@${VPS_HOST} "ls -la ${DEPLOY_PATH}/docker-compose.yml"

      - name: Create shared network if not exists
        run: |
          ssh ${{ inputs.ssh_user }}@${{ inputs.vps_host }} << 'ENDSSH'
          # Create shared network for inter-service communication (shared with agent)
          if ! docker network inspect resolvemeq-shared >/dev/null 2>&1; then
            docker network create resolvemeq-shared
            echo "Created resolvemeq-shared network"
          fi
          ENDSSH

      - name: Create .env file on VPS
        run: |
          ssh ${{ inputs.ssh_user }}@${{ inputs.vps_host }} << 'ENDSSH'
          cd ${{ inputs.deployment_path }}
          if [ ! -f .env ]; then
            echo "Creating new .env file from secrets..."
            cat > .env << 'EOF'
          DB_NAME=${{ secrets.DB_NAME }}
          DB_USER=${{ secrets.DB_USER }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          SECRET_KEY=${{ secrets.SECRET_KEY }}
          DEBUG=False
          ALLOWED_HOSTS=${{ secrets.ALLOWED_HOSTS }}
          AI_AGENT_URL=${{ secrets.AI_AGENT_URL }}
          SENTRY_DSN=${{ secrets.SENTRY_DSN }}
          ENVIRONMENT=production
          GITHUB_REPOSITORY_OWNER=${{ github.repository_owner }}
          IMAGE_TAG=${{ inputs.image_tag }}
          WEB_PORT=8000
          EOF
          else
            echo ".env file already exists, updating image tag..."
            sed -i 's/^IMAGE_TAG=.*/IMAGE_TAG=${{ inputs.image_tag }}/' .env
          fi
          ENDSSH

      - name: Login to GitHub Container Registry on VPS
        run: |
          ssh ${{ inputs.ssh_user }}@${{ inputs.vps_host }} "echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin"

      - name: Remove old images and pull fresh ones
        run: |
          ssh ${{ inputs.ssh_user }}@${{ inputs.vps_host }} "cd ${{ inputs.deployment_path }} && docker compose down || true && docker rmi ghcr.io/${{ github.repository_owner }}/resolvemeq-web:${{ inputs.image_tag }} || true && docker rmi ghcr.io/${{ github.repository_owner }}/resolvemeq-celery:${{ inputs.image_tag }} || true && docker compose pull --ignore-pull-failures"

      - name: Start services with Docker Compose
        run: |
          ssh ${{ inputs.ssh_user }}@${{ inputs.vps_host }} "cd ${{ inputs.deployment_path }} && docker compose up -d"

      - name: Run migrations in running container
        run: |
          ssh ${{ inputs.ssh_user }}@${{ inputs.vps_host }} "cd ${{ inputs.deployment_path }} && docker compose exec web python manage.py migrate --noinput"

      - name: Collect static files in running container
        run: |
          ssh ${{ inputs.ssh_user }}@${{ inputs.vps_host }} "cd ${{ inputs.deployment_path }} && docker compose exec web python manage.py collectstatic --noinput --clear"

      - name: Cleanup old images
        run: |
          ssh ${{ inputs.ssh_user }}@${{ inputs.vps_host }} "docker image prune -f"

      - name: Health check
        run: |
          ssh ${{ inputs.ssh_user }}@${{ inputs.vps_host }} << 'ENDSSH'
          cd ${{ inputs.deployment_path }}
          
          # Check if all services are running
          if docker compose ps | grep -q "Up"; then
            echo "✅ Deployment successful! Services are running."
            docker compose ps
          else
            echo "❌ Deployment failed! Some services are not running."
            docker compose logs --tail=50
            exit 1
          fi
          ENDSSH

      - name: Send deployment notification
        if: always()
        run: |
          echo "Deployment completed for image tag: ${{ inputs.image_tag }}"
          echo "Agent image tag: ${{ inputs.agent_image_tag }}"
          echo "VPS: ${{ inputs.vps_host }}"
          echo "Path: ${{ inputs.deployment_path }}"
